стр 304
 Раскрытие приватного состояния

Такая необходимость появляется только тогда, когда приватные методы не полностью покрываются тестами.
Правило здесь то же, что и с приватными методами: не раскрывайте состояние, которое вы бы без этого предпочли оставить приватным

стр 306 
Утечка доменных знаний в тесты

Такая ситуация происходит когдв в секции подготовки теста дубшлируется функционал самой системы.
стр 307
Тест не должен настаивать на конкретной реализации тестируемого алгоритма. Вместо того чтобы дублировать алгоритм,
зафиксируйте его результаты в тесте

стр 307 Загрязнение кода 
Загрязнение кода (code pollution) — добавление рабочего кода, который необходим
только для тестирования.
Например классу Logger в конструкторе передается параметр, который указывает, выполняется ли класс в рабочей среде.
Проблема с загрязнением кода заключается в том, что тестовый код смешивается
с рабочим кодом, что повышает затраты на сопровождение последнего.

стр 310 
Мокирование конкретных классов моками может сохранить часть функциональности
исходных классов, что иногда может быть полезно.(без использования интерфейсов)
Однако у этой альтернативы есть
значительный недостаток: она нарушает принцип единственной ответсвенности. ПОэтому нужно вынести часть реализации из класса в отдельный класс, реализовать через интерфейс и уже этот интерфейс мокировать

стр 312

 Работа со временем
Тестирование функциональности, зависящей от времени, может
привести к ложным срабатываниям: время в фазе действия может не совпасть со
временем в фазе проверки
Эту зависимость можно стабилизировать тремя способами. Один из этих трех способов является антипаттерном; из двух других один
предпочтительнее другого.
Первый вариант — использование паттерна «Неявный контекст» (Ambient context) АНТИПАТТЕРН Неявный контекст загрязняет
рабочий код и усложняет тестировани
стр 314 
Правильнее будет явно внедрить зависимость времени либо в виде сервиса либо в виде значения